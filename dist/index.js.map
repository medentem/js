{"version":3,"sources":["../src/constants.ts","../src/meshDevice.ts","../src/types.ts","../src/utils/index.ts","../src/utils/eventSystem.ts","../src/utils/general.ts","../src/utils/queue.ts","../src/utils/packetExtractor.ts","../src/utils/transformHandler.ts","../src/utils/xmodem.ts","../src/adapters/bleConnection.ts","../src/adapters/httpConnection.ts","../src/adapters/serialConnection.ts","../src/adapters/electronSerialConnection.ts","../src/client.ts","../src/index.ts"],"sourcesContent":["/** Bluetooth Low Energy ToRadio characteristic */\nexport const ToRadioUuid = \"f75c76d2-129e-4dad-a1dd-7866124401e7\";\n\n/** Bluetooth Low Energy FromRadio characteristic */\nexport const FromRadioUuid = \"2c55e69e-4993-11ed-b878-0242ac120002\";\n\n/**\n * Bluetooth Low Energy FromNum characteristic, provides BLE notification on new\n * FromRadio message and a message counter\n */\nexport const FromNumUuid = \"ed9da18c-a800-4f66-a670-aa7547e34453\";\n\n/** Bluetooth Service characteristic, used to identify Meshtastic devices */\nexport const ServiceUuid = \"6ba1b218-15a8-461f-9fa8-5dcae273eafd\";\n\n/** Broadcast destination number */\nexport const broadcastNum = 0xffffffff;\n\n/** Minimum device firmware version supported by this version of the library. */\nexport const minFwVer = 2.2;\n\nexport const Constants = {\n  ToRadioUuid,\n  FromRadioUuid,\n  FromNumUuid,\n  ServiceUuid,\n  broadcastNum,\n  minFwVer,\n};\n","import { Logger } from \"tslog\";\nimport { broadcastNum, minFwVer } from \"./constants.ts\";\nimport * as Protobuf from \"@meshtastic/protobufs\";\nimport * as Types from \"./types.ts\";\nimport { EventSystem, Queue, Xmodem } from \"./utils/index.ts\";\nimport { create, fromBinary, toBinary } from \"@bufbuild/protobuf\";\n\n/** Base class for connection methods to extend */\nexport abstract class MeshDevice {\n  /** Abstract property that states the connection type */\n  protected abstract connType: Types.ConnectionTypeName;\n\n  protected abstract portId: string;\n\n  /** Logs to the console and the logging event emitter */\n  protected log: Logger<unknown>;\n\n  /** Describes the current state of the device */\n  protected deviceStatus: Types.DeviceStatusEnum;\n\n  /** Describes the current state of the device */\n  protected isConfigured: boolean;\n\n  /** Are there any settings that have yet to be applied? */\n  protected pendingSettingsChanges: boolean;\n\n  /** Device's node number */\n  private myNodeInfo: Protobuf.Mesh.MyNodeInfo;\n\n  /** Randomly generated number to ensure confiuration lockstep */\n  public configId: number;\n\n  /**\n   * Packert queue, to space out transmissions and routing handle errors and\n   * acks\n   */\n  public queue: Queue;\n\n  public events: EventSystem;\n\n  public xModem: Xmodem;\n\n  constructor(configId?: number) {\n    this.log = new Logger({\n      name: \"iMeshDevice\",\n      prettyLogTemplate:\n        \"{{hh}}:{{MM}}:{{ss}}:{{ms}}\\t{{logLevelName}}\\t[{{name}}]\\t\",\n    });\n\n    this.deviceStatus = Types.DeviceStatusEnum.DeviceDisconnected;\n    this.isConfigured = false;\n    this.pendingSettingsChanges = false;\n    this.myNodeInfo = create(Protobuf.Mesh.MyNodeInfoSchema);\n    this.configId = configId ?? this.generateRandId();\n    this.queue = new Queue();\n    this.events = new EventSystem();\n    this.xModem = new Xmodem(this.sendRaw.bind(this)); //TODO: try wihtout bind\n\n    this.events.onDeviceStatus.subscribe((status) => {\n      this.deviceStatus = status;\n      if (status === Types.DeviceStatusEnum.DeviceConfigured) {\n        this.isConfigured = true;\n      } else if (status === Types.DeviceStatusEnum.DeviceConfiguring) {\n        this.isConfigured = false;\n      }\n    });\n\n    this.events.onMyNodeInfo.subscribe((myNodeInfo) => {\n      this.myNodeInfo = myNodeInfo;\n    });\n\n    this.events.onPendingSettingsChange.subscribe((state) => {\n      this.pendingSettingsChanges = state;\n    });\n  }\n\n  /** Abstract method that writes data to the radio */\n  protected abstract writeToRadio(data: Uint8Array): Promise<void>;\n\n  /** Abstract method that connects to the radio */\n  protected abstract connect(\n    parameters: Types.ConnectionParameters,\n  ): Promise<void>;\n\n  /** Abstract method that disconnects from the radio */\n  protected abstract disconnect(): void;\n\n  /** Abstract method that pings the radio */\n  protected abstract ping(): Promise<boolean>;\n\n  /**\n   * Sends a text over the radio\n   */\n  public async sendText(\n    text: string,\n    destination?: Types.Destination,\n    wantAck?: boolean,\n    channel?: Types.ChannelNumber,\n  ): Promise<number> {\n    this.log.debug(\n      Types.Emitter[Types.Emitter.SendText],\n      `üì§ Sending message to ${destination ?? \"broadcast\"} on channel ${\n        channel?.toString() ?? 0\n      }`,\n    );\n\n    const enc = new TextEncoder();\n\n    return await this.sendPacket(\n      enc.encode(text),\n      Protobuf.Portnums.PortNum.TEXT_MESSAGE_APP,\n      destination ?? \"broadcast\",\n      channel,\n      wantAck,\n      false,\n      true,\n    );\n  }\n\n  /**\n   * Sends a text over the radio\n   */\n  public sendWaypoint(\n    waypointMessage: Protobuf.Mesh.Waypoint,\n    destination: Types.Destination,\n    channel?: Types.ChannelNumber,\n  ): Promise<number> {\n    this.log.debug(\n      Types.Emitter[Types.Emitter.SendWaypoint],\n      `üì§ Sending waypoint to ${destination} on channel ${\n        channel?.toString() ?? 0\n      }`,\n    );\n\n    waypointMessage.id = this.generateRandId();\n\n    return this.sendPacket(\n      toBinary(Protobuf.Mesh.WaypointSchema, waypointMessage),\n      Protobuf.Portnums.PortNum.WAYPOINT_APP,\n      destination,\n      channel,\n      true,\n      false,\n    );\n  }\n\n  /**\n   * Sends packet over the radio\n   */\n  public async sendPacket(\n    byteData: Uint8Array,\n    portNum: Protobuf.Portnums.PortNum,\n    destination: Types.Destination,\n    channel: Types.ChannelNumber = Types.ChannelNumber.Primary,\n    wantAck = true,\n    wantResponse = true,\n    echoResponse = false,\n    replyId?: number,\n    emoji?: number,\n  ): Promise<number> {\n    this.log.trace(\n      Types.Emitter[Types.Emitter.SendPacket],\n      `üì§ Sending ${Protobuf.Portnums.PortNum[portNum]} to ${destination}`,\n    );\n\n    const meshPacket = create(Protobuf.Mesh.MeshPacketSchema, {\n      payloadVariant: {\n        case: \"decoded\",\n        value: {\n          payload: byteData,\n          portnum: portNum,\n          wantResponse,\n          emoji,\n          replyId,\n          dest: 0, //change this!\n          requestId: 0, //change this!\n          source: 0, //change this!\n        },\n      },\n      from: this.myNodeInfo.myNodeNum,\n      to:\n        destination === \"broadcast\"\n          ? broadcastNum\n          : destination === \"self\"\n            ? this.myNodeInfo.myNodeNum\n            : destination,\n      id: this.generateRandId(),\n      wantAck: wantAck,\n      channel,\n    });\n\n    const toRadioMessage = create(Protobuf.Mesh.ToRadioSchema, {\n      payloadVariant: {\n        case: \"packet\",\n        value: meshPacket,\n      },\n    });\n\n    if (echoResponse) {\n      meshPacket.rxTime = Math.trunc(new Date().getTime() / 1000);\n      this.handleMeshPacket(meshPacket);\n    }\n    return await this.sendRaw(\n      toBinary(Protobuf.Mesh.ToRadioSchema, toRadioMessage),\n      meshPacket.id,\n    );\n  }\n\n  /**\n   * Sends raw packet over the radio\n   */\n  public async sendRaw(\n    toRadio: Uint8Array,\n    id: number = this.generateRandId(),\n  ): Promise<number> {\n    if (toRadio.length > 512) {\n      throw new Error(\"Message longer than 512 bytes, it will not be sent!\");\n    }\n    this.queue.push({\n      id,\n      data: toRadio,\n    });\n\n    await this.queue.processQueue(async (data) => {\n      await this.writeToRadio(data);\n    });\n\n    return this.queue.wait(id);\n  }\n\n  /**\n   * Writes config to device\n   */\n  public async setConfig(config: Protobuf.Config.Config): Promise<number> {\n    this.log.debug(\n      Types.Emitter[Types.Emitter.SetConfig],\n      `‚öôÔ∏è Setting config, Variant: ${config.payloadVariant.case ?? \"Unknown\"}`,\n    );\n\n    if (!this.pendingSettingsChanges) {\n      await this.beginEditSettings();\n    }\n\n    const configMessage = create(Protobuf.Admin.AdminMessageSchema, {\n      payloadVariant: {\n        case: \"setConfig\",\n        value: config,\n      },\n    });\n\n    return this.sendPacket(\n      toBinary(Protobuf.Admin.AdminMessageSchema, configMessage),\n      Protobuf.Portnums.PortNum.ADMIN_APP,\n      \"self\",\n    );\n  }\n\n  /**\n   * Writes module config to device\n   */\n  public async setModuleConfig(\n    moduleConfig: Protobuf.ModuleConfig.ModuleConfig,\n  ): Promise<number> {\n    this.log.debug(\n      Types.Emitter[Types.Emitter.SetModuleConfig],\n      \"‚öôÔ∏è Setting module config\",\n    );\n\n    const moduleConfigMessage = create(Protobuf.Admin.AdminMessageSchema, {\n      payloadVariant: {\n        case: \"setModuleConfig\",\n        value: moduleConfig,\n      },\n    });\n\n    return await this.sendPacket(\n      toBinary(Protobuf.Admin.AdminMessageSchema, moduleConfigMessage),\n      Protobuf.Portnums.PortNum.ADMIN_APP,\n      \"self\",\n    );\n  }\n\n  // Write cannedMessages to device\n  public async setCannedMessages(\n    cannedMessages: Protobuf.CannedMessages.CannedMessageModuleConfig,\n  ): Promise<number> {\n    this.log.debug(\n      Types.Emitter[Types.Emitter.SetCannedMessages],\n      \"‚öôÔ∏è Setting CannedMessages\",\n    );\n\n    const cannedMessagesMessage = create(Protobuf.Admin.AdminMessageSchema, {\n      payloadVariant: {\n        case: \"setCannedMessageModuleMessages\",\n        value: cannedMessages.messages,\n      },\n    });\n\n    return await this.sendPacket(\n      toBinary(Protobuf.Admin.AdminMessageSchema, cannedMessagesMessage),\n      Protobuf.Portnums.PortNum.ADMIN_APP,\n      \"self\",\n    );\n  }\n\n  /**\n   * Sets devices owner data\n   */\n  public async setOwner(owner: Protobuf.Mesh.User): Promise<number> {\n    this.log.debug(Types.Emitter[Types.Emitter.SetOwner], \"üë§ Setting owner\");\n\n    const setOwnerMessage = create(Protobuf.Admin.AdminMessageSchema, {\n      payloadVariant: {\n        case: \"setOwner\",\n        value: owner,\n      },\n    });\n\n    return await this.sendPacket(\n      toBinary(Protobuf.Admin.AdminMessageSchema, setOwnerMessage),\n      Protobuf.Portnums.PortNum.ADMIN_APP,\n      \"self\",\n    );\n  }\n\n  /**\n   * Sets devices ChannelSettings\n   */\n  public async setChannel(channel: Protobuf.Channel.Channel): Promise<number> {\n    this.log.debug(\n      Types.Emitter[Types.Emitter.SetChannel],\n      `üìª Setting Channel: ${channel.index}`,\n    );\n\n    const setChannelMessage = create(Protobuf.Admin.AdminMessageSchema, {\n      payloadVariant: {\n        case: \"setChannel\",\n        value: channel,\n      },\n    });\n\n    return await this.sendPacket(\n      toBinary(Protobuf.Admin.AdminMessageSchema, setChannelMessage),\n      Protobuf.Portnums.PortNum.ADMIN_APP,\n      \"self\",\n    );\n  }\n\n  public async setPosition(\n    positionMessage: Protobuf.Mesh.Position,\n  ): Promise<number> {\n    return await this.sendPacket(\n      toBinary(Protobuf.Mesh.PositionSchema, positionMessage),\n      Protobuf.Portnums.PortNum.POSITION_APP,\n      \"self\",\n    );\n  }\n\n  /**\n   * Gets specified channel information from the radio\n   */\n  public async getChannel(index: number): Promise<number> {\n    this.log.debug(\n      Types.Emitter[Types.Emitter.GetChannel],\n      `üìª Requesting Channel: ${index}`,\n    );\n\n    const getChannelRequestMessage = create(Protobuf.Admin.AdminMessageSchema, {\n      payloadVariant: {\n        case: \"getChannelRequest\",\n        value: index + 1,\n      },\n    });\n\n    return await this.sendPacket(\n      toBinary(Protobuf.Admin.AdminMessageSchema, getChannelRequestMessage),\n      Protobuf.Portnums.PortNum.ADMIN_APP,\n      \"self\",\n    );\n  }\n\n  /**\n   * Gets devices config\n   *   request\n   */\n  public async getConfig(\n    configType: Protobuf.Admin.AdminMessage_ConfigType,\n  ): Promise<number> {\n    this.log.debug(\n      Types.Emitter[Types.Emitter.GetConfig],\n      \"‚öôÔ∏è Requesting config\",\n    );\n\n    const getRadioRequestMessage = create(Protobuf.Admin.AdminMessageSchema, {\n      payloadVariant: {\n        case: \"getConfigRequest\",\n        value: configType,\n      },\n    });\n\n    return await this.sendPacket(\n      toBinary(Protobuf.Admin.AdminMessageSchema, getRadioRequestMessage),\n      Protobuf.Portnums.PortNum.ADMIN_APP,\n      \"self\",\n    );\n  }\n\n  /**\n   * Gets Module config\n   */\n  public async getModuleConfig(\n    moduleConfigType: Protobuf.Admin.AdminMessage_ModuleConfigType,\n  ): Promise<number> {\n    this.log.debug(\n      Types.Emitter[Types.Emitter.GetModuleConfig],\n      \"‚öôÔ∏è Requesting module config\",\n    );\n\n    const getRadioRequestMessage = create(Protobuf.Admin.AdminMessageSchema, {\n      payloadVariant: {\n        case: \"getModuleConfigRequest\",\n        value: moduleConfigType,\n      },\n    });\n\n    return await this.sendPacket(\n      toBinary(Protobuf.Admin.AdminMessageSchema, getRadioRequestMessage),\n      Protobuf.Portnums.PortNum.ADMIN_APP,\n      \"self\",\n    );\n  }\n\n  /** Gets devices Owner */\n  public async getOwner(): Promise<number> {\n    this.log.debug(\n      Types.Emitter[Types.Emitter.GetOwner],\n      \"üë§ Requesting owner\",\n    );\n\n    const getOwnerRequestMessage = create(Protobuf.Admin.AdminMessageSchema, {\n      payloadVariant: {\n        case: \"getOwnerRequest\",\n        value: true,\n      },\n    });\n\n    return await this.sendPacket(\n      toBinary(Protobuf.Admin.AdminMessageSchema, getOwnerRequestMessage),\n      Protobuf.Portnums.PortNum.ADMIN_APP,\n      \"self\",\n    );\n  }\n\n  /**\n   * Gets devices metadata\n   */\n  public async getMetadata(nodeNum: number): Promise<number> {\n    this.log.debug(\n      Types.Emitter[Types.Emitter.GetMetadata],\n      `üè∑Ô∏è Requesting metadata from ${nodeNum}`,\n    );\n\n    const getDeviceMetricsRequestMessage = create(\n      Protobuf.Admin.AdminMessageSchema,\n      {\n        payloadVariant: {\n          case: \"getDeviceMetadataRequest\",\n          value: true,\n        },\n      },\n    );\n\n    return await this.sendPacket(\n      toBinary(\n        Protobuf.Admin.AdminMessageSchema,\n        getDeviceMetricsRequestMessage,\n      ),\n      Protobuf.Portnums.PortNum.ADMIN_APP,\n      nodeNum,\n      Types.ChannelNumber.Admin,\n    );\n  }\n\n  /**\n   * Clears specific channel with the designated index\n   */\n  public async clearChannel(index: number): Promise<number> {\n    this.log.debug(\n      Types.Emitter[Types.Emitter.ClearChannel],\n      `üìª Clearing Channel ${index}`,\n    );\n\n    const channel = create(Protobuf.Channel.ChannelSchema, {\n      index,\n      role: Protobuf.Channel.Channel_Role.DISABLED,\n    });\n    const setChannelMessage = create(Protobuf.Admin.AdminMessageSchema, {\n      payloadVariant: {\n        case: \"setChannel\",\n        value: channel,\n      },\n    });\n\n    return await this.sendPacket(\n      toBinary(Protobuf.Admin.AdminMessageSchema, setChannelMessage),\n      Protobuf.Portnums.PortNum.ADMIN_APP,\n      \"self\",\n    );\n  }\n\n  private async beginEditSettings(): Promise<number> {\n    this.events.onPendingSettingsChange.dispatch(true);\n\n    const beginEditSettings = create(Protobuf.Admin.AdminMessageSchema, {\n      payloadVariant: {\n        case: \"beginEditSettings\",\n        value: true,\n      },\n    });\n\n    return await this.sendPacket(\n      toBinary(Protobuf.Admin.AdminMessageSchema, beginEditSettings),\n      Protobuf.Portnums.PortNum.ADMIN_APP,\n      \"self\",\n    );\n  }\n\n  public async commitEditSettings(): Promise<number> {\n    this.events.onPendingSettingsChange.dispatch(false);\n\n    const commitEditSettings = create(Protobuf.Admin.AdminMessageSchema, {\n      payloadVariant: {\n        case: \"commitEditSettings\",\n        value: true,\n      },\n    });\n\n    return await this.sendPacket(\n      toBinary(Protobuf.Admin.AdminMessageSchema, commitEditSettings),\n      Protobuf.Portnums.PortNum.ADMIN_APP,\n      \"self\",\n    );\n  }\n\n  /**\n   * Resets the internal NodeDB of the radio, usefull for removing old nodes\n   * that no longer exist.\n   */\n  public async resetNodes(): Promise<number> {\n    this.log.debug(\n      Types.Emitter[Types.Emitter.ResetNodes],\n      \"üìª Resetting NodeDB\",\n    );\n\n    const resetNodes = create(Protobuf.Admin.AdminMessageSchema, {\n      payloadVariant: {\n        case: \"nodedbReset\",\n        value: 1,\n      },\n    });\n\n    return await this.sendPacket(\n      toBinary(Protobuf.Admin.AdminMessageSchema, resetNodes),\n      Protobuf.Portnums.PortNum.ADMIN_APP,\n      \"self\",\n    );\n  }\n\n  /**\n   * Removes a node from the internal NodeDB of the radio by node number\n   */\n  public async removeNodeByNum(nodeNum: number): Promise<number> {\n    this.log.debug(\n      Types.Emitter[Types.Emitter.RemoveNodeByNum],\n      `üìª Removing Node ${nodeNum} from NodeDB`,\n    );\n\n    const removeNodeByNum = create(Protobuf.Admin.AdminMessageSchema, {\n      payloadVariant: {\n        case: \"removeByNodenum\",\n        value: nodeNum,\n      },\n    });\n\n    return await this.sendPacket(\n      toBinary(Protobuf.Admin.AdminMessageSchema, removeNodeByNum),\n      Protobuf.Portnums.PortNum.ADMIN_APP,\n      \"self\",\n    );\n  }\n\n  /** Shuts down the current node after the specified amount of time has elapsed. */\n  public async shutdown(time: number): Promise<number> {\n    this.log.debug(\n      Types.Emitter[Types.Emitter.Shutdown],\n      `üîå Shutting down ${time > 2 ? \"now\" : `in ${time} seconds`}`,\n    );\n\n    const shutdown = create(Protobuf.Admin.AdminMessageSchema, {\n      payloadVariant: {\n        case: \"shutdownSeconds\",\n        value: time,\n      },\n    });\n\n    return await this.sendPacket(\n      toBinary(Protobuf.Admin.AdminMessageSchema, shutdown),\n      Protobuf.Portnums.PortNum.ADMIN_APP,\n      \"self\",\n    );\n  }\n\n  /** Reboots the current node after the specified amount of time has elapsed. */\n  public async reboot(time: number): Promise<number> {\n    this.log.debug(\n      Types.Emitter[Types.Emitter.Reboot],\n      `üîå Rebooting node ${time > 0 ? \"now\" : `in ${time} seconds`}`,\n    );\n\n    const reboot = create(Protobuf.Admin.AdminMessageSchema, {\n      payloadVariant: {\n        case: \"rebootSeconds\",\n        value: time,\n      },\n    });\n\n    return await this.sendPacket(\n      toBinary(Protobuf.Admin.AdminMessageSchema, reboot),\n      Protobuf.Portnums.PortNum.ADMIN_APP,\n      \"self\",\n    );\n  }\n\n  /**\n   * Reboots the current node into OTA mode after the specified amount of time\n   * has elapsed.\n   */\n  public async rebootOta(time: number): Promise<number> {\n    this.log.debug(\n      Types.Emitter[Types.Emitter.RebootOta],\n      `üîå Rebooting into OTA mode ${time > 0 ? \"now\" : `in ${time} seconds`}`,\n    );\n\n    const rebootOta = create(Protobuf.Admin.AdminMessageSchema, {\n      payloadVariant: {\n        case: \"rebootOtaSeconds\",\n        value: time,\n      },\n    });\n\n    return await this.sendPacket(\n      toBinary(Protobuf.Admin.AdminMessageSchema, rebootOta),\n      Protobuf.Portnums.PortNum.ADMIN_APP,\n      \"self\",\n    );\n  }\n\n  /** Factory resets the current device */\n  public async factoryResetDevice(): Promise<number> {\n    this.log.debug(\n      Types.Emitter[Types.Emitter.FactoryReset],\n      \"‚ôªÔ∏è Factory resetting device\",\n    );\n\n    const factoryReset = create(Protobuf.Admin.AdminMessageSchema, {\n      payloadVariant: {\n        case: \"factoryResetDevice\",\n        value: 1,\n      },\n    });\n\n    return await this.sendPacket(\n      toBinary(Protobuf.Admin.AdminMessageSchema, factoryReset),\n      Protobuf.Portnums.PortNum.ADMIN_APP,\n      \"self\",\n    );\n  }\n\n  /** Factory resets the current config */\n  public async factoryResetConfig(): Promise<number> {\n    this.log.debug(\n      Types.Emitter[Types.Emitter.FactoryReset],\n      \"‚ôªÔ∏è Factory resetting config\",\n    );\n\n    const factoryReset = create(Protobuf.Admin.AdminMessageSchema, {\n      payloadVariant: {\n        case: \"factoryResetConfig\",\n        value: 1,\n      },\n    });\n\n    return await this.sendPacket(\n      toBinary(Protobuf.Admin.AdminMessageSchema, factoryReset),\n      Protobuf.Portnums.PortNum.ADMIN_APP,\n      \"self\",\n    );\n  }\n\n  /** Triggers the device configure process */\n  public configure(): Promise<number> {\n    this.log.debug(\n      Types.Emitter[Types.Emitter.Configure],\n      \"‚öôÔ∏è Requesting device configuration\",\n    );\n    this.updateDeviceStatus(Types.DeviceStatusEnum.DeviceConfiguring);\n\n    const toRadio = create(Protobuf.Mesh.ToRadioSchema, {\n      payloadVariant: {\n        case: \"wantConfigId\",\n        value: this.configId,\n      },\n    });\n\n    return this.sendRaw(toBinary(Protobuf.Mesh.ToRadioSchema, toRadio));\n  }\n\n  /** Sends a trace route packet to the designated node */\n  public async traceRoute(destination: number): Promise<number> {\n    const routeDiscovery = create(Protobuf.Mesh.RouteDiscoverySchema, {\n      route: [],\n    });\n\n    return await this.sendPacket(\n      toBinary(Protobuf.Mesh.RouteDiscoverySchema, routeDiscovery),\n      Protobuf.Portnums.PortNum.TRACEROUTE_APP,\n      destination,\n    );\n  }\n\n  /** Requests position from the designated node */\n  public async requestPosition(destination: number): Promise<number> {\n    return await this.sendPacket(\n      new Uint8Array(),\n      Protobuf.Portnums.PortNum.POSITION_APP,\n      destination,\n    );\n  }\n\n  /**\n   * Updates the device status eliminating duplicate status events\n   */\n  public updateDeviceStatus(status: Types.DeviceStatusEnum): void {\n    if (status !== this.deviceStatus) {\n      this.events.onDeviceStatus.dispatch(status);\n    }\n  }\n\n  /**\n   * Generates random packet identifier\n   *\n   * @returns {number} Random packet ID\n   */\n  private generateRandId(): number {\n    const seed = crypto.getRandomValues(new Uint32Array(1));\n    if (!seed[0]) {\n      throw new Error(\"Cannot generate CSPRN\");\n    }\n\n    return Math.floor(seed[0] * 2 ** -32 * 1e9);\n  }\n\n  /**\n   * Gets called whenever a fromRadio message is received from device, returns\n   * fromRadio data\n   */\n  protected handleFromRadio(fromRadio: Uint8Array): void {\n    const decodedMessage = fromBinary(Protobuf.Mesh.FromRadioSchema, fromRadio);\n    this.events.onFromRadio.dispatch(decodedMessage);\n\n    /** @todo Add map here when `all=true` gets fixed. */\n    switch (decodedMessage.payloadVariant.case) {\n      case \"packet\": {\n        this.handleMeshPacket(decodedMessage.payloadVariant.value);\n        break;\n      }\n\n      case \"myInfo\": {\n        this.events.onMyNodeInfo.dispatch(decodedMessage.payloadVariant.value);\n        this.log.info(\n          Types.Emitter[Types.Emitter.HandleFromRadio],\n          \"üì± Received Node info for this device\",\n        );\n        break;\n      }\n\n      case \"nodeInfo\": {\n        this.log.info(\n          Types.Emitter[Types.Emitter.HandleFromRadio],\n          `üì± Received Node Info packet for node: ${decodedMessage.payloadVariant.value.num}`,\n        );\n\n        this.events.onNodeInfoPacket.dispatch(\n          decodedMessage.payloadVariant.value,\n        );\n\n        //TODO: HERE\n        if (decodedMessage.payloadVariant.value.position) {\n          this.events.onPositionPacket.dispatch({\n            id: decodedMessage.id,\n            rxTime: new Date(),\n            from: decodedMessage.payloadVariant.value.num,\n            to: decodedMessage.payloadVariant.value.num,\n            type: \"direct\",\n            channel: Types.ChannelNumber.Primary,\n            data: decodedMessage.payloadVariant.value.position,\n          });\n        }\n\n        //TODO: HERE\n        if (decodedMessage.payloadVariant.value.user) {\n          this.events.onUserPacket.dispatch({\n            id: decodedMessage.id,\n            rxTime: new Date(),\n            from: decodedMessage.payloadVariant.value.num,\n            to: decodedMessage.payloadVariant.value.num,\n            type: \"direct\",\n            channel: Types.ChannelNumber.Primary,\n            data: decodedMessage.payloadVariant.value.user,\n          });\n        }\n        break;\n      }\n\n      case \"config\": {\n        if (decodedMessage.payloadVariant.value.payloadVariant.case) {\n          this.log.trace(\n            Types.Emitter[Types.Emitter.HandleFromRadio],\n            `üíæ Received Config packet of variant: ${decodedMessage.payloadVariant.value.payloadVariant.case}`,\n          );\n        } else {\n          this.log.warn(\n            Types.Emitter[Types.Emitter.HandleFromRadio],\n            `‚ö†Ô∏è Received Config packet of variant: ${\"UNK\"}`,\n          );\n        }\n\n        this.events.onConfigPacket.dispatch(\n          decodedMessage.payloadVariant.value,\n        );\n        break;\n      }\n\n      case \"logRecord\": {\n        this.log.trace(\n          Types.Emitter[Types.Emitter.HandleFromRadio],\n          \"Received onLogRecord\",\n        );\n        this.events.onLogRecord.dispatch(decodedMessage.payloadVariant.value);\n        break;\n      }\n\n      case \"configCompleteId\": {\n        if (decodedMessage.payloadVariant.value !== this.configId) {\n          this.log.error(\n            Types.Emitter[Types.Emitter.HandleFromRadio],\n            `‚ùå Invalid config id received from device, expected ${this.configId} but received ${decodedMessage.payloadVariant.value}`,\n          );\n        }\n\n        this.log.info(\n          Types.Emitter[Types.Emitter.HandleFromRadio],\n          `‚öôÔ∏è Valid config id received from device: ${this.configId}`,\n        );\n\n        this.updateDeviceStatus(Types.DeviceStatusEnum.DeviceConfigured);\n        break;\n      }\n\n      case \"rebooted\": {\n        this.configure().catch(() => {\n          // TODO: FIX, workaround for `wantConfigId` not getting acks.\n        });\n        break;\n      }\n\n      case \"moduleConfig\": {\n        if (decodedMessage.payloadVariant.value.payloadVariant.case) {\n          this.log.trace(\n            Types.Emitter[Types.Emitter.HandleFromRadio],\n            `üíæ Received Module Config packet of variant: ${decodedMessage.payloadVariant.value.payloadVariant.case}`,\n          );\n        } else {\n          this.log.warn(\n            Types.Emitter[Types.Emitter.HandleFromRadio],\n            \"‚ö†Ô∏è Received Module Config packet of variant: UNK\",\n          );\n        }\n\n        this.events.onModuleConfigPacket.dispatch(\n          decodedMessage.payloadVariant.value,\n        );\n        break;\n      }\n\n      case \"channel\": {\n        this.log.trace(\n          Types.Emitter[Types.Emitter.HandleFromRadio],\n          `üîê Received Channel: ${decodedMessage.payloadVariant.value.index}`,\n        );\n\n        this.events.onChannelPacket.dispatch(\n          decodedMessage.payloadVariant.value,\n        );\n        break;\n      }\n\n      case \"queueStatus\": {\n        this.log.trace(\n          Types.Emitter[Types.Emitter.HandleFromRadio],\n          `üöß Received Queue Status: ${decodedMessage.payloadVariant.value}`,\n        );\n\n        this.events.onQueueStatus.dispatch(decodedMessage.payloadVariant.value);\n        break;\n      }\n\n      case \"xmodemPacket\": {\n        this.xModem.handlePacket(decodedMessage.payloadVariant.value);\n        break;\n      }\n\n      case \"metadata\": {\n        if (\n          Number.parseFloat(\n            decodedMessage.payloadVariant.value.firmwareVersion,\n          ) < minFwVer\n        ) {\n          this.log.fatal(\n            Types.Emitter[Types.Emitter.HandleFromRadio],\n            `Device firmware outdated. Min supported: ${minFwVer} got : ${decodedMessage.payloadVariant.value.firmwareVersion}`,\n          );\n        }\n        this.log.debug(\n          Types.Emitter[Types.Emitter.GetMetadata],\n          \"üè∑Ô∏è Received metadata packet\",\n        );\n\n        this.events.onDeviceMetadataPacket.dispatch({\n          id: decodedMessage.id,\n          rxTime: new Date(),\n          from: 0,\n          to: 0,\n          type: \"direct\",\n          channel: Types.ChannelNumber.Primary,\n          data: decodedMessage.payloadVariant.value,\n        });\n        break;\n      }\n\n      case \"mqttClientProxyMessage\": {\n        break;\n      }\n\n      default: {\n        this.log.warn(\n          Types.Emitter[Types.Emitter.HandleFromRadio],\n          `‚ö†Ô∏è Unhandled payload variant: ${decodedMessage.payloadVariant.case}`,\n        );\n      }\n    }\n  }\n\n  /** Completes all Events */\n  public complete(): void {\n    this.queue.clear();\n  }\n\n  /**\n   * Gets called when a MeshPacket is received from device\n   */\n  private handleMeshPacket(meshPacket: Protobuf.Mesh.MeshPacket): void {\n    this.events.onMeshPacket.dispatch(meshPacket);\n    if (meshPacket.from !== this.myNodeInfo.myNodeNum) {\n      /**\n       * TODO: this shouldn't be called unless the device interracts with the\n       * mesh, currently it does.\n       */\n      this.events.onMeshHeartbeat.dispatch(new Date());\n    }\n\n    switch (meshPacket.payloadVariant.case) {\n      case \"decoded\": {\n        this.handleDecodedPacket(meshPacket.payloadVariant.value, meshPacket);\n        break;\n      }\n\n      case \"encrypted\": {\n        this.log.debug(\n          Types.Emitter[Types.Emitter.HandleMeshPacket],\n          \"üîê Device received encrypted data packet, ignoring.\",\n        );\n        break;\n      }\n\n      default:\n        throw new Error(`Unhandled case ${meshPacket.payloadVariant.case}`);\n    }\n  }\n\n  private handleDecodedPacket(\n    dataPacket: Protobuf.Mesh.Data,\n    meshPacket: Protobuf.Mesh.MeshPacket,\n  ) {\n    let adminMessage: Protobuf.Admin.AdminMessage | undefined = undefined;\n    let routingPacket: Protobuf.Mesh.Routing | undefined = undefined;\n\n    const packetMetadata: Omit<Types.PacketMetadata<unknown>, \"data\"> = {\n      id: meshPacket.id,\n      rxTime: new Date(meshPacket.rxTime * 1000),\n      type: meshPacket.to === broadcastNum ? \"broadcast\" : \"direct\",\n      from: meshPacket.from,\n      to: meshPacket.to,\n      channel: meshPacket.channel,\n    };\n\n    this.log.trace(\n      Types.Emitter[Types.Emitter.HandleMeshPacket],\n      `üì¶ Received ${Protobuf.Portnums.PortNum[dataPacket.portnum]} packet`,\n    );\n\n    switch (dataPacket.portnum) {\n      case Protobuf.Portnums.PortNum.TEXT_MESSAGE_APP: {\n        this.events.onMessagePacket.dispatch({\n          ...packetMetadata,\n          data: new TextDecoder().decode(dataPacket.payload),\n        });\n        break;\n      }\n\n      case Protobuf.Portnums.PortNum.REMOTE_HARDWARE_APP: {\n        this.events.onRemoteHardwarePacket.dispatch({\n          ...packetMetadata,\n          data: fromBinary(\n            Protobuf.RemoteHardware.HardwareMessageSchema,\n            dataPacket.payload,\n          ),\n        });\n        break;\n      }\n\n      case Protobuf.Portnums.PortNum.POSITION_APP: {\n        this.events.onPositionPacket.dispatch({\n          ...packetMetadata,\n          data: fromBinary(Protobuf.Mesh.PositionSchema, dataPacket.payload),\n        });\n        break;\n      }\n\n      case Protobuf.Portnums.PortNum.NODEINFO_APP: {\n        this.events.onUserPacket.dispatch({\n          ...packetMetadata,\n          data: fromBinary(Protobuf.Mesh.UserSchema, dataPacket.payload),\n        });\n        break;\n      }\n\n      case Protobuf.Portnums.PortNum.ROUTING_APP: {\n        routingPacket = fromBinary(\n          Protobuf.Mesh.RoutingSchema,\n          dataPacket.payload,\n        );\n\n        this.events.onRoutingPacket.dispatch({\n          ...packetMetadata,\n          data: routingPacket,\n        });\n        switch (routingPacket.variant.case) {\n          case \"errorReason\": {\n            if (\n              routingPacket.variant.value === Protobuf.Mesh.Routing_Error.NONE\n            ) {\n              this.queue.processAck(dataPacket.requestId);\n            } else {\n              this.queue.processError({\n                id: dataPacket.requestId,\n                error: routingPacket.variant.value,\n              });\n            }\n\n            break;\n          }\n          case \"routeReply\": {\n            break;\n          }\n          case \"routeRequest\": {\n            break;\n          }\n\n          default: {\n            throw new Error(`Unhandled case ${routingPacket.variant.case}`);\n          }\n        }\n        break;\n      }\n\n      case Protobuf.Portnums.PortNum.ADMIN_APP: {\n        adminMessage = fromBinary(\n          Protobuf.Admin.AdminMessageSchema,\n          dataPacket.payload,\n        );\n        switch (adminMessage.payloadVariant.case) {\n          case \"getChannelResponse\": {\n            this.events.onChannelPacket.dispatch(\n              adminMessage.payloadVariant.value,\n            );\n            break;\n          }\n          case \"getOwnerResponse\": {\n            this.events.onUserPacket.dispatch({\n              ...packetMetadata,\n              data: adminMessage.payloadVariant.value,\n            });\n            break;\n          }\n          case \"getConfigResponse\": {\n            this.events.onConfigPacket.dispatch(\n              adminMessage.payloadVariant.value,\n            );\n            break;\n          }\n          case \"getModuleConfigResponse\": {\n            this.events.onModuleConfigPacket.dispatch(\n              adminMessage.payloadVariant.value,\n            );\n            break;\n          }\n          case \"getDeviceMetadataResponse\": {\n            this.log.debug(\n              Types.Emitter[Types.Emitter.GetMetadata],\n              `üè∑Ô∏è Received metadata packet from ${dataPacket.source}`,\n            );\n\n            this.events.onDeviceMetadataPacket.dispatch({\n              ...packetMetadata,\n              data: adminMessage.payloadVariant.value,\n            });\n            break;\n          }\n          default: {\n            this.log.error(\n              Types.Emitter[Types.Emitter.HandleMeshPacket],\n              `‚ö†Ô∏è Received unhandled AdminMessage, type ${\n                adminMessage.payloadVariant.case ?? \"undefined\"\n              }`,\n              dataPacket.payload,\n            );\n          }\n        }\n        break;\n      }\n\n      case Protobuf.Portnums.PortNum.WAYPOINT_APP: {\n        this.events.onWaypointPacket.dispatch({\n          ...packetMetadata,\n          data: fromBinary(Protobuf.Mesh.WaypointSchema, dataPacket.payload),\n        });\n        break;\n      }\n\n      case Protobuf.Portnums.PortNum.AUDIO_APP: {\n        this.events.onAudioPacket.dispatch({\n          ...packetMetadata,\n          data: dataPacket.payload,\n        });\n        break;\n      }\n\n      case Protobuf.Portnums.PortNum.DETECTION_SENSOR_APP: {\n        this.events.onDetectionSensorPacket.dispatch({\n          ...packetMetadata,\n          data: dataPacket.payload,\n        });\n        break;\n      }\n\n      case Protobuf.Portnums.PortNum.REPLY_APP: {\n        this.events.onPingPacket.dispatch({\n          ...packetMetadata,\n          data: dataPacket.payload, //TODO: decode\n        });\n        break;\n      }\n\n      case Protobuf.Portnums.PortNum.IP_TUNNEL_APP: {\n        this.events.onIpTunnelPacket.dispatch({\n          ...packetMetadata,\n          data: dataPacket.payload,\n        });\n        break;\n      }\n\n      case Protobuf.Portnums.PortNum.PAXCOUNTER_APP: {\n        this.events.onPaxcounterPacket.dispatch({\n          ...packetMetadata,\n          data: fromBinary(\n            Protobuf.PaxCount.PaxcountSchema,\n            dataPacket.payload,\n          ),\n        });\n        break;\n      }\n\n      case Protobuf.Portnums.PortNum.SERIAL_APP: {\n        this.events.onSerialPacket.dispatch({\n          ...packetMetadata,\n          data: dataPacket.payload,\n        });\n        break;\n      }\n\n      case Protobuf.Portnums.PortNum.STORE_FORWARD_APP: {\n        this.events.onStoreForwardPacket.dispatch({\n          ...packetMetadata,\n          data: dataPacket.payload,\n        });\n        break;\n      }\n\n      case Protobuf.Portnums.PortNum.RANGE_TEST_APP: {\n        this.events.onRangeTestPacket.dispatch({\n          ...packetMetadata,\n          data: dataPacket.payload,\n        });\n        break;\n      }\n\n      case Protobuf.Portnums.PortNum.TELEMETRY_APP: {\n        this.events.onTelemetryPacket.dispatch({\n          ...packetMetadata,\n          data: fromBinary(\n            Protobuf.Telemetry.TelemetrySchema,\n            dataPacket.payload,\n          ),\n        });\n        break;\n      }\n\n      case Protobuf.Portnums.PortNum.ZPS_APP: {\n        this.events.onZpsPacket.dispatch({\n          ...packetMetadata,\n          data: dataPacket.payload,\n        });\n        break;\n      }\n\n      case Protobuf.Portnums.PortNum.SIMULATOR_APP: {\n        this.events.onSimulatorPacket.dispatch({\n          ...packetMetadata,\n          data: dataPacket.payload,\n        });\n        break;\n      }\n\n      case Protobuf.Portnums.PortNum.TRACEROUTE_APP: {\n        this.events.onTraceRoutePacket.dispatch({\n          ...packetMetadata,\n          data: fromBinary(\n            Protobuf.Mesh.RouteDiscoverySchema,\n            dataPacket.payload,\n          ),\n        });\n        break;\n      }\n\n      case Protobuf.Portnums.PortNum.NEIGHBORINFO_APP: {\n        this.events.onNeighborInfoPacket.dispatch({\n          ...packetMetadata,\n          data: fromBinary(\n            Protobuf.Mesh.NeighborInfoSchema,\n            dataPacket.payload,\n          ),\n        });\n        break;\n      }\n\n      case Protobuf.Portnums.PortNum.ATAK_PLUGIN: {\n        this.events.onAtakPluginPacket.dispatch({\n          ...packetMetadata,\n          data: dataPacket.payload,\n        });\n        break;\n      }\n\n      case Protobuf.Portnums.PortNum.MAP_REPORT_APP: {\n        this.events.onMapReportPacket.dispatch({\n          ...packetMetadata,\n          data: dataPacket.payload,\n        });\n        break;\n      }\n\n      case Protobuf.Portnums.PortNum.PRIVATE_APP: {\n        this.events.onPrivatePacket.dispatch({\n          ...packetMetadata,\n          data: dataPacket.payload,\n        });\n        break;\n      }\n\n      case Protobuf.Portnums.PortNum.ATAK_FORWARDER: {\n        this.events.onAtakForwarderPacket.dispatch({\n          ...packetMetadata,\n          data: dataPacket.payload,\n        });\n        break;\n      }\n\n      default:\n        throw new Error(`Unhandled case ${dataPacket.portnum}`);\n    }\n  }\n}\n","import type {\n  BleConnection,\n  ElectronSerialConnection,\n  HttpConnection,\n  SerialConnection,\n} from \"./adapters/index.ts\";\nimport type * as Protobuf from \"@meshtastic/protobufs\";\n\nexport interface QueueItem {\n  id: number;\n  data: Uint8Array;\n  sent: boolean;\n  added: Date;\n  promise: Promise<number>;\n}\n\nexport enum DeviceStatusEnum {\n  DeviceRestarting = 1,\n  DeviceDisconnected = 2,\n  DeviceConnecting = 3,\n  DeviceReconnecting = 4,\n  DeviceConnected = 5,\n  DeviceConfiguring = 6,\n  DeviceConfigured = 7,\n}\n\nexport type ConnectionParameters =\n  | HttpConnectionParameters\n  | BleConnectionParameters\n  | SerialConnectionParameters;\n\nexport interface HttpConnectionParameters {\n  /** Address The IP Address/Domain to connect to, without protocol */\n  address: string;\n  /**\n   * Enables transport layer security. Notes: Slower, devices' certificate must\n   * be trusted by the browser\n   */\n  tls?: boolean;\n  /** Enables receiving messages all at once, versus one per request */\n  receiveBatchRequests?: boolean;\n  /**\n   * (ms) Sets a fixed interval in that the device is fetched for new messages,\n   * defaults to 5 seconds\n   */\n  fetchInterval: number;\n}\n\nexport interface BleConnectionParameters {\n  /** Optional filter options for the web bluetooth api requestDevice() method */\n  deviceFilter?: RequestDeviceOptions;\n  /** Connect directly to a Bluetooth deivce, obtained from `getDevices()` */\n  device?: BluetoothDevice;\n}\n\nexport interface SerialConnectionParameters {\n  baudRate?: number;\n  /** Connect directly to a Serial port, obtained from `getPorts()` */\n  port?: SerialPort;\n  concurrentLogOutput: boolean;\n}\n\nexport interface ElectronSerialConnectionParameters {\n  baudRate?: number;\n  path: string;\n  concurrentLogOutput: boolean;\n}\n\nexport type LogEventPacket = LogEvent & { date: Date };\n\nexport type PacketDestination = \"broadcast\" | \"direct\";\n\nexport interface PacketMetadata<T> {\n  id: number;\n  rxTime: Date;\n  type: PacketDestination;\n  from: number;\n  to: number;\n  channel: ChannelNumber;\n  data: T;\n}\n\nexport enum EmitterScope {\n  MeshDevice = 1,\n  SerialConnection = 2,\n  NodeSerialConnection = 3,\n  BleConnection = 4,\n  HttpConnection = 5,\n}\n\nexport enum Emitter {\n  Constructor = 0,\n  SendText = 1,\n  SendWaypoint = 2,\n  SendPacket = 3,\n  SendRaw = 4,\n  SetConfig = 5,\n  SetModuleConfig = 6,\n  ConfirmSetConfig = 7,\n  SetOwner = 8,\n  SetChannel = 9,\n  ConfirmSetChannel = 10,\n  ClearChannel = 11,\n  GetChannel = 12,\n  GetAllChannels = 13,\n  GetConfig = 14,\n  GetModuleConfig = 15,\n  GetOwner = 16,\n  Configure = 17,\n  HandleFromRadio = 18,\n  HandleMeshPacket = 19,\n  Connect = 20,\n  Ping = 21,\n  ReadFromRadio = 22,\n  WriteToRadio = 23,\n  SetDebugMode = 24,\n  GetMetadata = 25,\n  ResetNodes = 26,\n  Shutdown = 27,\n  Reboot = 28,\n  RebootOta = 29,\n  FactoryReset = 30,\n  EnterDfuMode = 31,\n  RemoveNodeByNum = 32,\n  SetCannedMessages = 33,\n}\n\nexport interface LogEvent {\n  scope: EmitterScope;\n  emitter: Emitter;\n  message: string;\n  level: Protobuf.Mesh.LogRecord_Level;\n  packet?: Uint8Array;\n}\n\nexport enum ChannelNumber {\n  Primary = 0,\n  Channel1 = 1,\n  Channel2 = 2,\n  Channel3 = 3,\n  Channel4 = 4,\n  Channel5 = 5,\n  Channel6 = 6,\n  Admin = 7,\n}\n\nexport type ConnectionType =\n  | BleConnection\n  | HttpConnection\n  | SerialConnection\n  | ElectronSerialConnection;\n\nexport type ConnectionTypeName = \"ble\" | \"http\" | \"serial\" | \"electron-serial\";\n\nexport type Destination = number | \"self\" | \"broadcast\";\n\nexport interface PacketError {\n  id: number;\n  error: Protobuf.Mesh.Routing_Error;\n}\n","export * from \"./eventSystem.ts\";\nexport * from \"./general.ts\";\nexport * from \"./queue.ts\";\nexport * from \"./transformHandler.ts\";\nexport * from \"./xmodem.ts\";\n","import { SimpleEventDispatcher } from \"ste-simple-events\";\nimport type * as Protobuf from \"@meshtastic/protobufs\";\nimport type { PacketMetadata } from \"../types.ts\";\nimport type * as Types from \"../types.ts\";\n\nexport class EventSystem {\n  /**\n   * Fires when a new FromRadio message has been received from the device\n   *\n   * @event onLogEvent\n   */\n  public readonly onLogEvent =\n    new SimpleEventDispatcher<Types.LogEventPacket>();\n\n  /**\n   * Fires when a new FromRadio message has been received from the device\n   *\n   * @event onFromRadio\n   */\n  public readonly onFromRadio =\n    new SimpleEventDispatcher<Protobuf.Mesh.FromRadio>();\n\n  /**\n   * Fires when a new FromRadio message containing a Data packet has been\n   * received from the device\n   *\n   * @event onMeshPacket\n   */\n  public readonly onMeshPacket =\n    new SimpleEventDispatcher<Protobuf.Mesh.MeshPacket>();\n\n  /**\n   * Fires when a new MyNodeInfo message has been received from the device\n   *\n   * @event onMyNodeInfo\n   */\n  public readonly onMyNodeInfo =\n    new SimpleEventDispatcher<Protobuf.Mesh.MyNodeInfo>();\n\n  /**\n   * Fires when a new MeshPacket message containing a NodeInfo packet has been\n   * received from device\n   *\n   * @event onNodeInfoPacket\n   */\n  public readonly onNodeInfoPacket =\n    new SimpleEventDispatcher<Protobuf.Mesh.NodeInfo>();\n\n  /**\n   * Fires when a new Channel message is received\n   *\n   * @event onChannelPacket\n   */\n  public readonly onChannelPacket =\n    new SimpleEventDispatcher<Protobuf.Channel.Channel>();\n\n  /**\n   * Fires when a new Config message is received\n   *\n   * @event onConfigPacket\n   */\n  public readonly onConfigPacket =\n    new SimpleEventDispatcher<Protobuf.Config.Config>();\n\n  /**\n   * Fires when a new ModuleConfig message is received\n   *\n   * @event onModuleConfigPacket\n   */\n  public readonly onModuleConfigPacket =\n    new SimpleEventDispatcher<Protobuf.ModuleConfig.ModuleConfig>();\n\n  /**\n   * Fires when a new MeshPacket message containing a ATAK packet has been\n   * received from device\n   *\n   * @event onAtakPacket\n   */\n  public readonly onAtakPacket = new SimpleEventDispatcher<\n    PacketMetadata<Uint8Array>\n  >();\n\n  /**\n   * Fires when a new MeshPacket message containing a Text packet has been\n   * received from device\n   *\n   * @event onMessagePacket\n   */\n  public readonly onMessagePacket = new SimpleEventDispatcher<\n    PacketMetadata<string>\n  >();\n\n  /**\n   * Fires when a new MeshPacket message containing a Remote Hardware packet has\n   * been received from device\n   *\n   * @event onRemoteHardwarePacket\n   */\n  public readonly onRemoteHardwarePacket = new SimpleEventDispatcher<\n    PacketMetadata<Protobuf.RemoteHardware.HardwareMessage>\n  >();\n\n  /**\n   * Fires when a new MeshPacket message containing a Position packet has been\n   * received from device\n   *\n   * @event onPositionPacket\n   */\n  public readonly onPositionPacket = new SimpleEventDispatcher<\n    PacketMetadata<Protobuf.Mesh.Position>\n  >();\n\n  /**\n   * Fires when a new MeshPacket message containing a User packet has been\n   * received from device\n   *\n   * @event onUserPacket\n   */\n  public readonly onUserPacket = new SimpleEventDispatcher<\n    PacketMetadata<Protobuf.Mesh.User>\n  >();\n\n  /**\n   * Fires when a new MeshPacket message containing a Routing packet has been\n   * received from device\n   *\n   * @event onRoutingPacket\n   */\n  public readonly onRoutingPacket = new SimpleEventDispatcher<\n    PacketMetadata<Protobuf.Mesh.Routing>\n  >();\n\n  /**\n   * Fires when the device receives a Metadata packet\n   *\n   * @event onDeviceMetadataPacket\n   */\n  public readonly onDeviceMetadataPacket = new SimpleEventDispatcher<\n    PacketMetadata<Protobuf.Mesh.DeviceMetadata>\n  >();\n\n  /**\n   * Fires when a new MeshPacket message containing a Waypoint packet has been\n   * received from device\n   *\n   * @event onWaypointPacket\n   */\n  public readonly onWaypointPacket = new SimpleEventDispatcher<\n    PacketMetadata<Protobuf.Mesh.Waypoint>\n  >();\n\n  /**\n   * Fires when a new MeshPacket message containing an Audio packet has been\n   * received from device\n   *\n   * @event onAudioPacket\n   */\n  public readonly onAudioPacket = new SimpleEventDispatcher<\n    PacketMetadata<Uint8Array>\n  >();\n\n  /**\n   * Fires when a new MeshPacket message containing a Detection Sensor packet has been\n   * received from device\n   *\n   * @event onDetectionSensorPacket\n   */\n  public readonly onDetectionSensorPacket = new SimpleEventDispatcher<\n    PacketMetadata<Uint8Array>\n  >();\n\n  /**\n   * Fires when a new MeshPacket message containing a Ping packet has been\n   * received from device\n   *\n   * @event onPingPacket\n   */\n  public readonly onPingPacket = new SimpleEventDispatcher<\n    PacketMetadata<Uint8Array>\n  >();\n\n  /**\n   * Fires when a new MeshPacket message containing a IP Tunnel packet has been\n   * received from device\n   *\n   * @event onIpTunnelPacket\n   */\n  public readonly onIpTunnelPacket = new SimpleEventDispatcher<\n    PacketMetadata<Uint8Array>\n  >();\n\n  /**\n   * Fires when a new MeshPacket message containing a Paxcounter packet has been\n   * received from device\n   *\n   * @event onPaxcounterPacket\n   */\n  public readonly onPaxcounterPacket = new SimpleEventDispatcher<\n    PacketMetadata<Protobuf.PaxCount.Paxcount>\n  >();\n\n  /**\n   * Fires when a new MeshPacket message containing a Serial packet has been\n   * received from device\n   *\n   * @event onSerialPacket\n   */\n  public readonly onSerialPacket = new SimpleEventDispatcher<\n    PacketMetadata<Uint8Array>\n  >();\n\n  /**\n   * Fires when a new MeshPacket message containing a Store and Forward packet\n   * has been received from device\n   *\n   * @event onStoreForwardPacket\n   */\n  public readonly onStoreForwardPacket = new SimpleEventDispatcher<\n    PacketMetadata<Uint8Array>\n  >();\n\n  /**\n   * Fires when a new MeshPacket message containing a Store and Forward packet\n   * has been received from device\n   *\n   * @event onRangeTestPacket\n   */\n  public readonly onRangeTestPacket = new SimpleEventDispatcher<\n    PacketMetadata<Uint8Array>\n  >();\n\n  /**\n   * Fires when a new MeshPacket message containing a Telemetry packet has been\n   * received from device\n   *\n   * @event onTelemetryPacket\n   */\n  public readonly onTelemetryPacket = new SimpleEventDispatcher<\n    PacketMetadata<Protobuf.Telemetry.Telemetry>\n  >();\n\n  /**\n   * Fires when a new MeshPacket message containing a ZPS packet has been\n   * received from device\n   *\n   * @event onZPSPacket\n   */\n  public readonly onZpsPacket = new SimpleEventDispatcher<\n    PacketMetadata<Uint8Array>\n  >();\n\n  /**\n   * Fires when a new MeshPacket message containing a Simulator packet has been\n   * received from device\n   *\n   * @event onSimulatorPacket\n   */\n  public readonly onSimulatorPacket = new SimpleEventDispatcher<\n    PacketMetadata<Uint8Array>\n  >();\n\n  /**\n   * Fires when a new MeshPacket message containing a Trace Route packet has been\n   * received from device\n   *\n   * @event onTraceRoutePacket\n   */\n  public readonly onTraceRoutePacket = new SimpleEventDispatcher<\n    PacketMetadata<Protobuf.Mesh.RouteDiscovery>\n  >();\n\n  /**\n   * Fires when a new MeshPacket message containing a Neighbor Info packet has been\n   * received from device\n   *\n   * @event onNeighborInfoPacket\n   */\n  public readonly onNeighborInfoPacket = new SimpleEventDispatcher<\n    PacketMetadata<Protobuf.Mesh.NeighborInfo>\n  >();\n\n  /**\n   * Fires when a new MeshPacket message containing an ATAK packet has been\n   * received from device\n   *\n   * @event onAtakPluginPacket\n   */\n  public readonly onAtakPluginPacket = new SimpleEventDispatcher<\n    PacketMetadata<Uint8Array>\n  >();\n\n  /**\n   * Fires when a new MeshPacket message containing a Map Report packet has been\n   * received from device\n   *\n   * @event onMapReportPacket\n   */\n  public readonly onMapReportPacket = new SimpleEventDispatcher<\n    PacketMetadata<Uint8Array>\n  >();\n\n  /**\n   * Fires when a new MeshPacket message containing a Private packet has been\n   * received from device\n   *\n   * @event onPrivatePacket\n   */\n  public readonly onPrivatePacket = new SimpleEventDispatcher<\n    PacketMetadata<Uint8Array>\n  >();\n\n  /**\n   * Fires when a new MeshPacket message containing an ATAK Forwarder packet has been\n   * received from device\n   *\n   * @event onAtakForwarderPacket\n   */\n  public readonly onAtakForwarderPacket = new SimpleEventDispatcher<\n    PacketMetadata<Uint8Array>\n  >();\n\n  /**\n   * Fires when the devices connection or configuration status changes\n   *\n   * @event onDeviceStatus\n   */\n  public readonly onDeviceStatus =\n    new SimpleEventDispatcher<Types.DeviceStatusEnum>();\n\n  /**\n   * Fires when a new FromRadio message containing a LogRecord packet has been\n   * received from device\n   *\n   * @event onLogRecord\n   */\n  public readonly onLogRecord =\n    new SimpleEventDispatcher<Protobuf.Mesh.LogRecord>();\n\n  /**\n   * Fires when the device receives a meshPacket, returns a timestamp\n   *\n   * @event onMeshHeartbeat\n   */\n  public readonly onMeshHeartbeat = new SimpleEventDispatcher<Date>();\n\n  /**\n   * Outputs any debug log data (currently serial connections only)\n   *\n   * @event onDeviceDebugLog\n   */\n  public readonly onDeviceDebugLog = new SimpleEventDispatcher<Uint8Array>();\n\n  /**\n   * Outputs status of pending settings changes\n   *\n   * @event onpendingSettingsChange\n   */\n  public readonly onPendingSettingsChange =\n    new SimpleEventDispatcher<boolean>();\n\n  /**\n   * Fires when a QueueStatus message is generated\n   *\n   * @event onQueueStatus\n   */\n  public readonly onQueueStatus =\n    new SimpleEventDispatcher<Protobuf.Mesh.QueueStatus>();\n}\n","/**\n * Converts a `Uint8Array` to an `ArrayBuffer`\n */\nexport const typedArrayToBuffer = (array: Uint8Array): ArrayBuffer => {\n  return array.buffer.slice(\n    array.byteOffset,\n    array.byteLength + array.byteOffset,\n  );\n};\n","import { SimpleEventDispatcher } from \"ste-simple-events\";\nimport { fromBinary } from \"@bufbuild/protobuf\";\nimport * as Protobuf from \"@meshtastic/protobufs\";\nimport type { PacketError, QueueItem } from \"../types.ts\";\n\nexport class Queue {\n  private queue: QueueItem[] = [];\n  private lock = false;\n  private ackNotifier = new SimpleEventDispatcher<number>();\n  private errorNotifier = new SimpleEventDispatcher<PacketError>();\n  private timeout: number;\n\n  constructor() {\n    this.timeout = 60000;\n  }\n\n  public getState(): QueueItem[] {\n    return this.queue;\n  }\n\n  public clear(): void {\n    this.queue = [];\n  }\n\n  public push(item: Omit<QueueItem, \"promise\" | \"sent\" | \"added\">): void {\n    const queueItem: QueueItem = {\n      ...item,\n      sent: false,\n      added: new Date(),\n      promise: new Promise<number>((resolve, reject) => {\n        this.ackNotifier.subscribe((id) => {\n          if (item.id === id) {\n            this.remove(item.id);\n            resolve(id);\n          }\n        });\n        this.errorNotifier.subscribe((e) => {\n          if (item.id === e.id) {\n            this.remove(item.id);\n            reject(e);\n          }\n        });\n        setTimeout(() => {\n          if (this.queue.findIndex((qi) => qi.id === item.id) !== -1) {\n            this.remove(item.id);\n            const decoded = fromBinary(Protobuf.Mesh.ToRadioSchema, item.data);\n            console.warn(\n              `Packet ${item.id} of type ${decoded.payloadVariant.case} timed out`,\n            );\n\n            reject({\n              id: item.id,\n              error: Protobuf.Mesh.Routing_Error.TIMEOUT,\n            });\n          }\n        }, this.timeout);\n      }),\n    };\n    this.queue.push(queueItem);\n  }\n\n  public remove(id: number): void {\n    if (this.lock) {\n      setTimeout(() => this.remove(id), 100);\n      return;\n    }\n    this.queue = this.queue.filter((item) => item.id !== id);\n  }\n\n  public processAck(id: number): void {\n    this.ackNotifier.dispatch(id);\n  }\n\n  public processError(e: PacketError): void {\n    console.error(\n      `Error received for packet ${e.id}: ${\n        Protobuf.Mesh.Routing_Error[e.error]\n      }`,\n    );\n    this.errorNotifier.dispatch(e);\n  }\n\n  public async wait(id: number): Promise<number> {\n    const queueItem = this.queue.find((qi) => qi.id === id);\n    if (!queueItem) {\n      throw new Error(\"Packet does not exist\");\n    }\n    return queueItem.promise;\n  }\n\n  public async processQueue(\n    writeToRadio: (data: Uint8Array) => Promise<void>,\n  ): Promise<void> {\n    if (this.lock) {\n      return;\n    }\n    this.lock = true;\n    while (this.queue.filter((p) => !p.sent).length > 0) {\n      const item = this.queue.filter((p) => !p.sent)[0];\n      if (item) {\n        await new Promise((resolve) => setTimeout(resolve, 200));\n        try {\n          await writeToRadio(item.data);\n          item.sent = true;\n        } catch (error) {\n          console.error(`Error sending packet ${item.id}`, error);\n        }\n      }\n    }\n    this.lock = false;\n  }\n}\n","import * as Protobuf from \"@meshtastic/protobufs\";\nimport * as Types from \"../types.ts\";\nimport type { Logger } from \"tslog\";\nimport type { SimpleEventDispatcher } from \"ste-simple-events\";\n\nexport class PacketExtractor {\n  protected byteBuffer: Uint8Array;\n\n  constructor() {\n    this.byteBuffer = new Uint8Array([]);\n  }\n\n  public tryExtractPacket(\n    chunk: Uint8Array,\n    log: Logger<unknown>,\n    onDeviceDebugLog: SimpleEventDispatcher<Uint8Array>,\n    concurrentLogOutput: boolean,\n  ): Uint8Array | undefined {\n    this.byteBuffer = new Uint8Array([...this.byteBuffer, ...chunk]);\n    let processingExhausted = false;\n    while (this.byteBuffer.length !== 0 && !processingExhausted) {\n      const framingIndex = this.byteBuffer.findIndex((byte) => byte === 0x94);\n      const framingByte2 = this.byteBuffer[framingIndex + 1];\n      if (framingByte2 === 0xc3) {\n        if (this.byteBuffer.subarray(0, framingIndex).length) {\n          if (concurrentLogOutput) {\n            onDeviceDebugLog.dispatch(\n              this.byteBuffer.subarray(0, framingIndex),\n            );\n          } else {\n            log.warn(\n              Types.EmitterScope.SerialConnection,\n              Types.Emitter.Connect,\n              `‚ö†Ô∏è Found unneccesary message padding, removing: ${this.byteBuffer\n                .subarray(0, framingIndex)\n                .toString()}`,\n            );\n          }\n\n          this.byteBuffer = this.byteBuffer.subarray(framingIndex);\n        }\n\n        const msb = this.byteBuffer[2];\n        const lsb = this.byteBuffer[3];\n\n        if (\n          msb !== undefined &&\n          lsb !== undefined &&\n          this.byteBuffer.length >= 4 + (msb << 8) + lsb\n        ) {\n          const packet = this.byteBuffer.subarray(4, 4 + (msb << 8) + lsb);\n\n          const malformedDetectorIndex = packet.findIndex(\n            (byte) => byte === 0x94,\n          );\n          if (\n            malformedDetectorIndex !== -1 &&\n            packet[malformedDetectorIndex + 1] === 0xc3\n          ) {\n            log.warn(\n              Types.EmitterScope.SerialConnection,\n              Types.Emitter.Connect,\n              `‚ö†Ô∏è Malformed packet found, discarding: ${this.byteBuffer\n                .subarray(0, malformedDetectorIndex - 1)\n                .toString()}`,\n              Protobuf.Mesh.LogRecord_Level.WARNING,\n            );\n\n            this.byteBuffer = this.byteBuffer.subarray(malformedDetectorIndex);\n          } else {\n            this.byteBuffer = this.byteBuffer.subarray(\n              3 + (msb << 8) + lsb + 1,\n            );\n            return packet;\n          }\n        } else {\n          /** Only partial message in buffer, wait for the rest */\n          processingExhausted = true;\n        }\n      } else {\n        /** Message not complete, only 1 byte in buffer */\n        processingExhausted = true;\n      }\n    }\n    return undefined;\n  }\n}\n","import type { SimpleEventDispatcher } from \"ste-simple-events\";\nimport type { Logger } from \"tslog\";\nimport { PacketExtractor } from \"./packetExtractor.ts\";\n\nexport const transformHandler = (\n  log: Logger<unknown>,\n  onReleaseEvent: SimpleEventDispatcher<boolean>,\n  onDeviceDebugLog: SimpleEventDispatcher<Uint8Array>,\n  concurrentLogOutput: boolean,\n) => {\n  const packetExtractor = new PacketExtractor();\n  return new TransformStream<Uint8Array, Uint8Array>({\n    transform(chunk: Uint8Array, controller): void {\n      log = log.getSubLogger({ name: \"streamTransformer\" });\n      onReleaseEvent.subscribe(() => {\n        controller.terminate();\n      });\n      const packet = packetExtractor.tryExtractPacket(\n        chunk,\n        log,\n        onDeviceDebugLog,\n        concurrentLogOutput,\n      );\n      if (packet) {\n        controller.enqueue(packet);\n      }\n    },\n  });\n};\n","import crc16ccitt from \"crc/calculators/crc16ccitt\";\nimport { create, toBinary } from \"@bufbuild/protobuf\";\nimport * as Protobuf from \"@meshtastic/protobufs\";\n\n//if counter > 35 then reset counter/clear/error/reject promise\ntype XmodemProps = (toRadio: Uint8Array, id?: number) => Promise<number>;\n\nexport class Xmodem {\n  private sendRaw: XmodemProps;\n  private rxBuffer: Uint8Array[];\n  private txBuffer: Uint8Array[];\n  private textEncoder: TextEncoder;\n  private counter: number;\n\n  constructor(sendRaw: XmodemProps) {\n    this.sendRaw = sendRaw;\n    this.rxBuffer = [];\n    this.txBuffer = [];\n    this.textEncoder = new TextEncoder();\n    this.counter = 0;\n  }\n\n  async downloadFile(filename: string): Promise<number> {\n    return await this.sendCommand(\n      Protobuf.Xmodem.XModem_Control.STX,\n      this.textEncoder.encode(filename),\n      0,\n    );\n  }\n\n  async uploadFile(filename: string, data: Uint8Array): Promise<number> {\n    for (let i = 0; i < data.length; i += 128) {\n      this.txBuffer.push(data.slice(i, i + 128));\n    }\n\n    return await this.sendCommand(\n      Protobuf.Xmodem.XModem_Control.SOH,\n      this.textEncoder.encode(filename),\n      0,\n    );\n  }\n\n  async sendCommand(\n    command: Protobuf.Xmodem.XModem_Control,\n    buffer?: Uint8Array,\n    sequence?: number,\n    crc16?: number,\n  ): Promise<number> {\n    const toRadio = create(Protobuf.Mesh.ToRadioSchema, {\n      payloadVariant: {\n        case: \"xmodemPacket\",\n        value: {\n          buffer,\n          control: command,\n          seq: sequence,\n          crc16: crc16,\n        },\n      },\n    });\n    return await this.sendRaw(toBinary(Protobuf.Mesh.ToRadioSchema, toRadio));\n  }\n\n  async handlePacket(packet: Protobuf.Xmodem.XModem): Promise<number> {\n    await new Promise((resolve) => setTimeout(resolve, 100));\n\n    switch (packet.control) {\n      case Protobuf.Xmodem.XModem_Control.NUL: {\n        // nothing\n        break;\n      }\n      case Protobuf.Xmodem.XModem_Control.SOH: {\n        this.counter = packet.seq;\n        if (this.validateCrc16(packet)) {\n          this.rxBuffer[this.counter] = packet.buffer;\n          return this.sendCommand(Protobuf.Xmodem.XModem_Control.ACK);\n        }\n        return await this.sendCommand(\n          Protobuf.Xmodem.XModem_Control.NAK,\n          undefined,\n          packet.seq,\n        );\n      }\n      case Protobuf.Xmodem.XModem_Control.STX: {\n        break;\n      }\n      case Protobuf.Xmodem.XModem_Control.EOT: {\n        // end of transmission\n        break;\n      }\n      case Protobuf.Xmodem.XModem_Control.ACK: {\n        this.counter++;\n        if (this.txBuffer[this.counter - 1]) {\n          return this.sendCommand(\n            Protobuf.Xmodem.XModem_Control.SOH,\n            this.txBuffer[this.counter - 1],\n            this.counter,\n            crc16ccitt(this.txBuffer[this.counter - 1] ?? new Uint8Array()),\n          );\n        }\n        if (this.counter === this.txBuffer.length + 1) {\n          return this.sendCommand(Protobuf.Xmodem.XModem_Control.EOT);\n        }\n        this.clear();\n        break;\n      }\n      case Protobuf.Xmodem.XModem_Control.NAK: {\n        return this.sendCommand(\n          Protobuf.Xmodem.XModem_Control.SOH,\n          this.txBuffer[this.counter],\n          this.counter,\n          crc16ccitt(this.txBuffer[this.counter - 1] ?? new Uint8Array()),\n        );\n      }\n      case Protobuf.Xmodem.XModem_Control.CAN: {\n        this.clear();\n        break;\n      }\n      case Protobuf.Xmodem.XModem_Control.CTRLZ: {\n        break;\n      }\n    }\n\n    return Promise.resolve(0);\n  }\n\n  validateCrc16(packet: Protobuf.Xmodem.XModem): boolean {\n    return crc16ccitt(packet.buffer) === packet.crc16;\n  }\n\n  clear() {\n    this.counter = 0;\n    this.rxBuffer = [];\n    this.txBuffer = [];\n  }\n}\n","import {\n  FromNumUuid,\n  FromRadioUuid,\n  ServiceUuid,\n  ToRadioUuid,\n} from \"../constants.ts\";\nimport { MeshDevice } from \"../meshDevice.ts\";\nimport * as Types from \"../types.ts\";\nimport { typedArrayToBuffer } from \"../utils/index.ts\";\n\n/** Allows to connect to a Meshtastic device via bluetooth */\nexport class BleConnection extends MeshDevice {\n  /** Defines the connection type as ble */\n  public connType: Types.ConnectionTypeName;\n\n  public portId: string;\n\n  /** Currently connected BLE device */\n  public device: BluetoothDevice | undefined;\n\n  private gattServer: BluetoothRemoteGATTServer | undefined;\n\n  /** Short Description */\n  private service: BluetoothRemoteGATTService | undefined;\n\n  /** Short Description */\n  private toRadioCharacteristic: BluetoothRemoteGATTCharacteristic | undefined;\n\n  /** Short Description */\n  private fromRadioCharacteristic:\n    | BluetoothRemoteGATTCharacteristic\n    | undefined;\n\n  /** Short Description */\n  private fromNumCharacteristic: BluetoothRemoteGATTCharacteristic | undefined;\n\n  private timerUpdateFromRadio: NodeJS.Timeout | null = null;\n\n  constructor(configId?: number) {\n    super(configId);\n\n    this.log = this.log.getSubLogger({ name: \"HttpConnection\" });\n\n    this.connType = \"ble\";\n    this.portId = \"\";\n    this.device = undefined;\n    this.service = undefined;\n    this.gattServer = undefined;\n    this.toRadioCharacteristic = undefined;\n    this.fromRadioCharacteristic = undefined;\n    this.fromNumCharacteristic = undefined;\n    // this.pendingRead = false;\n\n    this.log.debug(\n      Types.Emitter[Types.Emitter.Constructor],\n      \"üî∑ BleConnection instantiated\",\n    );\n  }\n\n  /**\n   * Gets web bluetooth support avaliability for the device\n   *\n   * @returns {Promise<void>}\n   */\n  public supported(): Promise<boolean> {\n    return navigator.bluetooth.getAvailability();\n  }\n\n  /**\n   * Gets list of bluetooth devices that can be passed to `connect`\n   *\n   * @returns {Promise<BluetoothDevice[]>} Array of avaliable BLE devices\n   */\n  public getDevices(): Promise<BluetoothDevice[]> {\n    return navigator.bluetooth.getDevices();\n  }\n\n  /**\n   * Opens browser dialog to select a device\n   */\n  public getDevice(filter?: RequestDeviceOptions): Promise<BluetoothDevice> {\n    return navigator.bluetooth.requestDevice(\n      filter ?? {\n        filters: [{ services: [ServiceUuid] }],\n      },\n    );\n  }\n\n  /**\n   * Initiates the connect process to a Meshtastic device via Bluetooth\n   */\n  public async connect({\n    device,\n    deviceFilter,\n  }: Types.BleConnectionParameters): Promise<void> {\n    /** Set device state to connecting */\n    this.updateDeviceStatus(Types.DeviceStatusEnum.DeviceConnecting);\n\n    /** Set device if specified, else request. */\n    this.device = device ?? (await this.getDevice(deviceFilter));\n\n    this.portId = this.device.id;\n\n    /** Setup event listners */\n    this.device.addEventListener(\"gattserverdisconnected\", () => {\n      this.log.info(\n        Types.Emitter[Types.Emitter.Connect],\n        \"Device disconnected\",\n      );\n      this.updateDeviceStatus(Types.DeviceStatusEnum.DeviceDisconnected);\n      this.complete();\n    });\n\n    /** Connect to device */\n    await this.device.gatt\n      ?.connect()\n      .then((server) => {\n        this.log.info(\n          Types.Emitter[Types.Emitter.Connect],\n          `‚úÖ Got GATT Server for device: ${server.device.id}`,\n        );\n        this.gattServer = server;\n      })\n      .catch((e: Error) => {\n        this.log.error(\n          Types.Emitter[Types.Emitter.Connect],\n          `‚ùå Failed to connect: ${e.message}`,\n        );\n      });\n\n    await this.gattServer\n      ?.getPrimaryService(ServiceUuid)\n      .then((service) => {\n        this.log.info(\n          Types.Emitter[Types.Emitter.Connect],\n          `‚úÖ Got GATT Service for device: ${service.device.id}`,\n        );\n        this.service = service;\n      })\n      .catch((e: Error) => {\n        this.log.error(\n          Types.Emitter[Types.Emitter.Connect],\n          `‚ùå Failed to get primary service: q${e.message}`,\n        );\n      });\n\n    [ToRadioUuid, FromRadioUuid, FromNumUuid].map(async (uuid) => {\n      await this.service\n        ?.getCharacteristic(uuid)\n        .then((characteristic) => {\n          this.log.info(\n            Types.Emitter[Types.Emitter.Connect],\n            `‚úÖ Got Characteristic ${characteristic.uuid} for device: ${characteristic.uuid}`,\n          );\n          switch (uuid) {\n            case ToRadioUuid: {\n              this.toRadioCharacteristic = characteristic;\n              break;\n            }\n            case FromRadioUuid: {\n              this.fromRadioCharacteristic = characteristic;\n              break;\n            }\n            case FromNumUuid: {\n              this.fromNumCharacteristic = characteristic;\n              break;\n            }\n          }\n        })\n        .catch((e: Error) => {\n          this.log.error(\n            Types.Emitter[Types.Emitter.Connect],\n            `‚ùå Failed to get toRadio characteristic: q${e.message}`,\n          );\n        });\n    });\n\n    await this.fromNumCharacteristic?.startNotifications(); // TODO: catch\n\n    this.fromNumCharacteristic?.addEventListener(\n      \"characteristicvaluechanged\",\n      () => {\n        this.readFromRadio();\n      },\n    );\n\n    this.updateDeviceStatus(Types.DeviceStatusEnum.DeviceConnected);\n\n    this.configure().catch(() => {\n      // TODO: FIX, workaround for `wantConfigId` not getting acks.\n    });\n\n    this.timerUpdateFromRadio = setInterval(() => this.readFromRadio(), 1000);\n  }\n\n  /** Disconnects from the Meshtastic device */\n  public disconnect(): void {\n    this.device?.gatt?.disconnect();\n    this.updateDeviceStatus(Types.DeviceStatusEnum.DeviceDisconnected);\n    this.complete();\n    if (this.timerUpdateFromRadio) {\n      clearInterval(this.timerUpdateFromRadio);\n    }\n    this.timerUpdateFromRadio = null;\n  }\n\n  /**\n   * Pings device to check if it is avaliable\n   *\n   * @todo Implement\n   */\n  public async ping(): Promise<boolean> {\n    return await Promise.resolve(true);\n  }\n\n  /** Short description */\n  protected async readFromRadio(): Promise<void> {\n    // if (this.pendingRead) {\n    //   return Promise.resolve();\n    // }\n    // this.pendingRead = true;\n    let readBuffer = new ArrayBuffer(1);\n\n    while (readBuffer.byteLength > 0 && this.fromRadioCharacteristic) {\n      await this.fromRadioCharacteristic\n        .readValue()\n        .then((value) => {\n          readBuffer = value.buffer;\n\n          if (value.byteLength > 0) {\n            this.handleFromRadio(new Uint8Array(readBuffer));\n          }\n          this.updateDeviceStatus(Types.DeviceStatusEnum.DeviceConnected);\n        })\n        .catch((e: Error) => {\n          readBuffer = new ArrayBuffer(0);\n          this.log.error(\n            Types.Emitter[Types.Emitter.ReadFromRadio],\n            `‚ùå ${e.message}`,\n          );\n        });\n    }\n    // this.pendingRead = false;\n  }\n\n  /**\n   * Sends supplied protobuf message to the radio\n   */\n  protected async writeToRadio(data: Uint8Array): Promise<void> {\n    await this.toRadioCharacteristic?.writeValue(typedArrayToBuffer(data));\n    // This should be automatic (onCharacteristicValueChanged)\n    await this.readFromRadio();\n  }\n}\n","import { MeshDevice } from \"../meshDevice.ts\";\nimport * as Types from \"../types.ts\";\nimport { typedArrayToBuffer } from \"../utils/index.ts\";\n\n/** Allows to connect to a Meshtastic device over HTTP(S) */\nexport class HttpConnection extends MeshDevice {\n  /** Defines the connection type as http */\n  public connType: Types.ConnectionTypeName;\n\n  /** URL of the device that is to be connected to. */\n  protected portId: string;\n\n  /** Enables receiving messages all at once, versus one per request */\n  private receiveBatchRequests: boolean;\n\n  private readLoop: ReturnType<typeof setInterval> | null;\n\n  private pendingRequest: boolean;\n\n  private abortController: AbortController;\n\n  constructor(configId?: number) {\n    super(configId);\n\n    this.log = this.log.getSubLogger({ name: \"HttpConnection\" });\n\n    this.connType = \"http\";\n    this.portId = \"\";\n    this.receiveBatchRequests = false;\n    this.readLoop = null;\n    this.pendingRequest = false;\n    this.abortController = new AbortController();\n\n    this.log.debug(\n      Types.Emitter[Types.Emitter.Constructor],\n      \"üî∑ HttpConnection instantiated\",\n    );\n  }\n\n  /**\n   * Initiates the connect process to a Meshtastic device via HTTP(S)\n   */\n  public async connect({\n    address,\n    fetchInterval = 3000,\n    receiveBatchRequests = false,\n    tls = false,\n  }: Types.HttpConnectionParameters): Promise<void> {\n    this.updateDeviceStatus(Types.DeviceStatusEnum.DeviceConnecting);\n\n    this.receiveBatchRequests = receiveBatchRequests;\n\n    this.portId = `${tls ? \"https://\" : \"http://\"}${address}`;\n\n    if (\n      this.deviceStatus === Types.DeviceStatusEnum.DeviceConnecting &&\n      (await this.ping())\n    ) {\n      this.log.debug(\n        Types.Emitter[Types.Emitter.Connect],\n        \"Ping succeeded, starting configuration and request timer.\",\n      );\n      this.configure().catch(() => {\n        // TODO: FIX, workaround for `wantConfigId` not getting acks.\n      });\n      this.readLoop = setInterval(() => {\n        this.readFromRadio().catch((e: Error) => {\n          this.log.error(\n            Types.Emitter[Types.Emitter.Connect],\n            `‚ùå ${e.message}`,\n          );\n        });\n      }, fetchInterval);\n    } else if (\n      this.deviceStatus !== Types.DeviceStatusEnum.DeviceDisconnected\n    ) {\n      setTimeout(() => {\n        this.connect({\n          address: address,\n          fetchInterval: fetchInterval,\n          receiveBatchRequests: receiveBatchRequests,\n          tls: tls,\n        });\n      }, 10000);\n    }\n  }\n\n  /** Disconnects from the Meshtastic device */\n  public disconnect(): void {\n    this.abortController.abort();\n    this.updateDeviceStatus(Types.DeviceStatusEnum.DeviceDisconnected);\n    if (this.readLoop) {\n      clearInterval(this.readLoop);\n      this.complete();\n    }\n  }\n\n  /** Pings device to check if it is avaliable */\n  public async ping(): Promise<boolean> {\n    this.log.debug(\n      Types.Emitter[Types.Emitter.Ping],\n      \"Attempting device ping.\",\n    );\n\n    const { signal } = this.abortController;\n\n    let pingSuccessful = false;\n\n    await fetch(`${this.portId}/hotspot-detect.html`, {\n      signal,\n      mode: \"no-cors\",\n    })\n      .then(() => {\n        pingSuccessful = true;\n        this.updateDeviceStatus(Types.DeviceStatusEnum.DeviceConnected);\n      })\n      .catch((e: Error) => {\n        pingSuccessful = false;\n        this.log.error(Types.Emitter[Types.Emitter.Ping], `‚ùå ${e.message}`);\n        this.updateDeviceStatus(Types.DeviceStatusEnum.DeviceReconnecting);\n      });\n    return pingSuccessful;\n  }\n\n  /** Reads any avaliable protobuf messages from the radio */\n  protected async readFromRadio(): Promise<void> {\n    if (this.pendingRequest) {\n      return;\n    }\n    let readBuffer = new ArrayBuffer(1);\n    const { signal } = this.abortController;\n\n    while (readBuffer.byteLength > 0) {\n      this.pendingRequest = true;\n      await fetch(\n        `${this.portId}/api/v1/fromradio?all=${\n          this.receiveBatchRequests ? \"true\" : \"false\"\n        }`,\n        {\n          signal,\n          method: \"GET\",\n          headers: {\n            Accept: \"application/x-protobuf\",\n          },\n        },\n      )\n        .then(async (response) => {\n          this.pendingRequest = false;\n          this.updateDeviceStatus(Types.DeviceStatusEnum.DeviceConnected);\n\n          readBuffer = await response.arrayBuffer();\n\n          if (readBuffer.byteLength > 0) {\n            this.handleFromRadio(new Uint8Array(readBuffer));\n          }\n        })\n        .catch((e: Error) => {\n          this.pendingRequest = false;\n          this.log.error(\n            Types.Emitter[Types.Emitter.ReadFromRadio],\n            `‚ùå ${e.message}`,\n          );\n\n          this.updateDeviceStatus(Types.DeviceStatusEnum.DeviceReconnecting);\n        });\n    }\n  }\n\n  /**\n   * Sends supplied protobuf message to the radio\n   */\n  protected async writeToRadio(data: Uint8Array): Promise<void> {\n    const { signal } = this.abortController;\n\n    await fetch(`${this.portId}/api/v1/toradio`, {\n      signal,\n      method: \"PUT\",\n      headers: {\n        \"Content-Type\": \"application/x-protobuf\",\n      },\n      body: typedArrayToBuffer(data),\n    })\n      .then(async () => {\n        this.updateDeviceStatus(Types.DeviceStatusEnum.DeviceConnected);\n\n        await this.readFromRadio().catch((e: Error) => {\n          this.log.error(\n            Types.Emitter[Types.Emitter.WriteToRadio],\n            `‚ùå ${e.message}`,\n          );\n        });\n      })\n      .catch((e: Error) => {\n        this.log.error(\n          Types.Emitter[Types.Emitter.WriteToRadio],\n          `‚ùå ${e.message}`,\n        );\n        this.updateDeviceStatus(Types.DeviceStatusEnum.DeviceReconnecting);\n      });\n  }\n}\n","import { SimpleEventDispatcher } from \"ste-simple-events\";\nimport { MeshDevice } from \"../meshDevice.ts\";\nimport * as Types from \"../types.ts\";\nimport { transformHandler } from \"../utils/index.ts\";\n\n/** Allows to connect to a Meshtastic device over WebSerial */\nexport class SerialConnection extends MeshDevice {\n  /** Defines the connection type as serial */\n  public connType: Types.ConnectionTypeName;\n\n  protected portId: string;\n\n  /** Serial port used to communicate with device. */\n  public port: SerialPort | undefined;\n\n  private readerHack: ReadableStreamDefaultReader<Uint8Array> | undefined;\n\n  /** Transform stream for parsing raw serial data */\n  private transformer?: TransformStream<Uint8Array, Uint8Array>;\n\n  /** Should locks be prevented */\n  private preventLock?: boolean;\n\n  /** Unfortunately, this is currently the only way to release the lock on a stream after piping it\n   *  through a transform stream (https://stackoverflow.com/questions/71262432) */\n  private pipePromise?: Promise<void>;\n\n  /**\n   * Fires when `disconnect()` is called, used to instruct serial port and\n   * readers to release there locks\n   *\n   * @event onReleaseEvent\n   */\n  private readonly onReleaseEvent: SimpleEventDispatcher<boolean>;\n\n  constructor(configId?: number) {\n    super(configId);\n\n    this.log = this.log.getSubLogger({ name: \"SerialConnection\" });\n\n    this.connType = \"serial\";\n    this.portId = \"\";\n    this.port = undefined;\n    this.transformer = undefined;\n    this.onReleaseEvent = new SimpleEventDispatcher<boolean>();\n    this.preventLock = false;\n\n    this.log.debug(\n      Types.Emitter[Types.Emitter.Constructor],\n      \"üî∑ SerialConnection instantiated\",\n    );\n  }\n\n  /**\n   * Reads packets from transformed serial port steam and processes them.\n   */\n  private async readFromRadio(\n    reader: ReadableStreamDefaultReader<Uint8Array>,\n  ): Promise<void> {\n    this.onReleaseEvent.subscribe(async () => {\n      this.preventLock = true;\n      await reader.cancel();\n      await this.pipePromise?.catch(() => {});\n      reader.releaseLock();\n      await this.port?.close();\n    });\n\n    while (this.port?.readable && !this.preventLock) {\n      await reader\n        .read()\n        .then(({ value }) => {\n          if (value) {\n            this.handleFromRadio(value);\n          }\n        })\n        .catch(() => {\n          this.log.debug(\n            Types.Emitter[Types.Emitter.ReadFromRadio],\n            \"Releasing reader\",\n          );\n        });\n    }\n  }\n\n  /** Gets list of serial ports that can be passed to `connect` */\n  public async getPorts(): Promise<SerialPort[]> {\n    return await navigator.serial.getPorts();\n  }\n\n  /**\n   * Opens browsers connection dialogue to select a serial port\n   */\n  public async getPort(filter?: SerialPortRequestOptions): Promise<SerialPort> {\n    return await navigator.serial.requestPort(filter);\n  }\n\n  public getCurrentPort() {\n    return this.port;\n  }\n\n  /**\n   * Initiates the connect process to a Meshtastic device via Web Serial\n   */\n  public async connect({\n    port,\n    baudRate = 115200,\n    concurrentLogOutput = false,\n  }: Types.SerialConnectionParameters): Promise<void> {\n    /** Set device state to connecting */\n    this.updateDeviceStatus(Types.DeviceStatusEnum.DeviceConnecting);\n\n    /** Set device if specified, else request. */\n    this.port = port ?? (await this.getPort());\n\n    // this.portId = this.port. TODO: add once WebSerial adds unique/port identifiers\n\n    /** Setup event listners */\n    this.port.addEventListener(\"disconnect\", () => {\n      this.log.info(\n        Types.Emitter[Types.Emitter.Connect],\n        \"Device disconnected\",\n      );\n      this.updateDeviceStatus(Types.DeviceStatusEnum.DeviceDisconnected);\n      this.complete();\n    });\n\n    this.preventLock = false;\n    /** Connect to device */\n    await this.port\n      .open({\n        baudRate,\n      })\n      .then(() => {\n        if (this.port?.readable && this.port.writable) {\n          this.transformer = transformHandler(\n            this.log,\n            this.onReleaseEvent,\n            this.events.onDeviceDebugLog,\n            concurrentLogOutput,\n          );\n\n          this.pipePromise = this.port.readable.pipeTo(\n            this.transformer.writable,\n          );\n          const reader = (this.readerHack =\n            this.transformer.readable.getReader());\n          this.readFromRadio(reader);\n\n          this.updateDeviceStatus(Types.DeviceStatusEnum.DeviceConnected);\n\n          this.configure().catch(() => {\n            // TODO: FIX, workaround for `wantConfigId` not getting acks.\n          });\n        } else {\n          console.log(\"not readable or writable\");\n        }\n      })\n      .catch((e: Error) => {\n        this.log.error(Types.Emitter[Types.Emitter.Connect], `‚ùå ${e.message}`);\n      });\n  }\n\n  /** Disconnects from the serial port */\n  public async reconnect(): Promise<void> {\n    await this.connect({\n      port: this.port,\n      concurrentLogOutput: false,\n    });\n  }\n\n  /** Disconnects from the serial port */\n  public async disconnect(): Promise<SerialPort | undefined> {\n    // this.onReleaseEvent.dispatch(true);\n    // HACK: Inline onReleaseEvent\n    // -- This should be used as an event, like intened\n    this.preventLock = true;\n    await this.readerHack?.cancel();\n    await this.pipePromise?.catch(() => {});\n    this.readerHack?.releaseLock();\n    if (this.port?.readable) {\n      await this.port?.close();\n    }\n    // -------\n    this.updateDeviceStatus(Types.DeviceStatusEnum.DeviceDisconnected);\n    this.complete();\n    // await this.onReleaseEvent.toPromise();\n    return this.port;\n  }\n\n  /** Pings device to check if it is avaliable */\n  public async ping(): Promise<boolean> {\n    return await Promise.resolve(true);\n  }\n\n  /**\n   * Sends supplied protobuf message to the radio\n   */\n  protected async writeToRadio(data: Uint8Array): Promise<void> {\n    while (this.port?.writable?.locked) {\n      await new Promise((resolve) => setTimeout(resolve, 100));\n    }\n    const writer = this.port?.writable?.getWriter();\n\n    await writer?.write(\n      new Uint8Array([0x94, 0xc3, 0x00, data.length, ...data]),\n    );\n    writer?.releaseLock();\n  }\n}\n","import { MeshDevice } from \"../meshDevice.ts\";\nimport * as Types from \"../types.ts\";\nimport { ByteLengthParser, SerialPort } from \"serialport\";\nimport { PacketExtractor } from \"../utils/packetExtractor.ts\";\n\nexport interface PortInfo {\n  path: string;\n  manufacturer: string | undefined;\n  serialNumber: string | undefined;\n  pnpId: string | undefined;\n  locationId: string | undefined;\n  productId: string | undefined;\n  vendorId: string | undefined;\n}\n\n/** Allows to connect to a Meshtastic device over WebSerial */\nexport class ElectronSerialConnection extends MeshDevice {\n  /** Defines the connection type as serial */\n  public connType: Types.ConnectionTypeName;\n\n  protected portId: string;\n\n  protected packetExtractor: PacketExtractor;\n\n  /** Serial port used to communicate with device. */\n  public port: SerialPort | undefined;\n\n  constructor(configId?: number) {\n    super(configId);\n\n    this.log = this.log.getSubLogger({ name: \"ElectronSerialConnection\" });\n\n    this.connType = \"electron-serial\";\n    this.portId = \"\";\n    this.port = undefined;\n    this.packetExtractor = new PacketExtractor();\n\n    this.log.debug(\n      Types.Emitter[Types.Emitter.Constructor],\n      \"üî∑ ElectronSerialConnection instantiated\",\n    );\n  }\n\n  /** Gets list of serial ports that can be passed to `connect` */\n  public async getPorts(): Promise<PortInfo[]> {\n    return await SerialPort.list();\n  }\n\n  public getCurrentPort() {\n    return this.port;\n  }\n\n  /**\n   * Initiates the connect process to a Meshtastic device via Serial Port\n   */\n  public async connect({\n    path,\n    baudRate = 115200,\n  }: Types.ElectronSerialConnectionParameters): Promise<void> {\n    /** Set device state to connecting */\n    this.updateDeviceStatus(Types.DeviceStatusEnum.DeviceConnecting);\n\n    this.portId = path;\n\n    /** Set device if specified, else request. */\n    this.port = new SerialPort({\n      path,\n      baudRate,\n      autoOpen: false,\n    });\n\n    /** Setup event listners */\n    this.port.on(\"close\", () => {\n      this.log.info(\n        Types.Emitter[Types.Emitter.Connect],\n        \"Device disconnected\",\n      );\n      this.updateDeviceStatus(Types.DeviceStatusEnum.DeviceDisconnected);\n      this.complete();\n    });\n\n    this.port.on(\"error\", (err) => {\n      this.log.error(Types.Emitter[Types.Emitter.Connect], `‚ùå ${err.message}`);\n    });\n\n    this.port.on(\"open\", (err) => {\n      if (err) {\n        this.log.error(\n          Types.Emitter[Types.Emitter.Connect],\n          `‚ùå ${err.message}`,\n        );\n        return;\n      }\n\n      if (this.port?.readable) {\n        const parser = this.port.pipe(new ByteLengthParser({ length: 8 }));\n\n        parser.on(\"data\", (data) => {\n          const packet = this.packetExtractor.tryExtractPacket(\n            data,\n            this.log,\n            this.events.onDeviceDebugLog,\n            false,\n          );\n          if (packet) {\n            this.handleFromRadio(packet);\n          }\n        });\n\n        this.log.info(\n          Types.Emitter[Types.Emitter.Connect],\n          `üî∑ Connected to ${path}`,\n        );\n\n        this.configure().catch(() => {\n          // TODO: FIX, workaround for `wantConfigId` not getting acks.\n        });\n\n        this.updateDeviceStatus(Types.DeviceStatusEnum.DeviceConnected);\n      } else {\n        this.log.error(\n          Types.Emitter[Types.Emitter.Connect],\n          \"‚ùå Serial port not readable.\",\n        );\n      }\n    });\n\n    /** Connect to device */\n    this.port.open((err) => {\n      if (err) {\n        this.log.error(\n          Types.Emitter[Types.Emitter.Connect],\n          \"‚ùå Serial port failed to open.\",\n        );\n      } else {\n        this.log.info(\n          Types.Emitter[Types.Emitter.Connect],\n          `üî∑ Port open to ${path}`,\n        );\n      }\n    });\n  }\n\n  /** Reconnects to the serial port */\n  public async reconnect(): Promise<void> {\n    await this.connect({\n      path: this.portId,\n      concurrentLogOutput: false,\n    });\n  }\n\n  /** Disconnects from the serial port */\n  public async disconnect(): Promise<SerialPort | undefined> {\n    // -------\n    this.port?.close();\n    this.updateDeviceStatus(Types.DeviceStatusEnum.DeviceDisconnected);\n    this.complete();\n    // await this.onReleaseEvent.toPromise();\n    return this.port;\n  }\n\n  /** Pings device to check if it is avaliable */\n  public async ping(): Promise<boolean> {\n    return await Promise.resolve(true);\n  }\n\n  /**\n   * Sends supplied protobuf message to the radio\n   */\n  protected async writeToRadio(data: Uint8Array): Promise<void> {\n    await this.port?.write(\n      new Uint8Array([0x94, 0xc3, 0x00, data.length, ...data]),\n    );\n  }\n}\n","import {\n  BleConnection,\n  HttpConnection,\n  SerialConnection,\n  ElectronSerialConnection,\n} from \"./adapters/index.ts\";\nimport type * as Types from \"./types.ts\";\n\n/**\n * Allows to create new connections to devices and manages them. Alternatively,\n * new connections can be created directly by instantiating their respective the\n * interface classes.\n */\nexport class Client {\n  /** Array containing all created connection interfaces */\n  deviceInterfaces: Types.ConnectionType[];\n\n  constructor() {\n    this.deviceInterfaces = [];\n  }\n\n  /**\n   * Creates a new Bluetooth Low Enery connection interface\n   */\n  public createBleConnection(configId?: number): BleConnection {\n    const bleConnection = new BleConnection(configId);\n    this.deviceInterfaces.push(bleConnection);\n    return bleConnection;\n  }\n\n  /**\n   * Creates a new HTTP(S) connection interface\n   */\n  public createHttpConnection(configId?: number): HttpConnection {\n    const httpConnection = new HttpConnection(configId);\n    this.deviceInterfaces.push(httpConnection);\n    return httpConnection;\n  }\n\n  /**\n   * Creates a new Serial connection interface\n   */\n  public createSerialConnection(configId?: number): SerialConnection {\n    const serialConnection = new SerialConnection(configId);\n    this.deviceInterfaces.push(serialConnection);\n    return serialConnection;\n  }\n\n  /**\n   * Creates a new Electron Serial connection interface\n   */\n  public createElectronSerialConnection(\n    configId?: number,\n  ): ElectronSerialConnection {\n    const serialConnection = new ElectronSerialConnection(configId);\n    this.deviceInterfaces.push(serialConnection);\n    return serialConnection;\n  }\n\n  /**\n   * Adds an already created connection interface to the client\n   */\n  public addConnection(connectionObj: Types.ConnectionType): void {\n    this.deviceInterfaces.push(connectionObj);\n  }\n\n  /**\n   * Removes a connection interface from the client\n   */\n  public removeConnection(connectionObj: Types.ConnectionType): void {\n    const index = this.deviceInterfaces.indexOf(connectionObj);\n    if (index !== -1) {\n      this.deviceInterfaces.splice(index, 1);\n    }\n  }\n}\n","export * from \"./adapters/index.ts\";\nexport * from \"./client.ts\";\nexport * from \"./constants.ts\";\nexport * from \"./meshDevice.ts\";\nexport * as Protobuf from \"@meshtastic/protobufs\";\nexport * as Types from \"./types.ts\";\nexport * as Utils from \"./utils/index.ts\";\n"],"mappings":"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","names":["Protobuf","DeviceStatusEnum","EmitterScope","Emitter","ChannelNumber","Xmodem","SimpleEventDispatcher","Protobuf","Protobuf","Xmodem","create","fromBinary","toBinary","Xmodem","SimpleEventDispatcher","SimpleEventDispatcher","Protobuf"]}